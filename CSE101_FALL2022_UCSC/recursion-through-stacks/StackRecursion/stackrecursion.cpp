// Filename: stackrecursion.cpp
//
// The file basically contains two functions that generate all subsequences of an input string. One function is the (standard) recursive method,
// while the other is non-recursive and uses a stack. Both these functions have an identical output, and create a (linked) list of strings as their output.
// 
// The code uses the List data structure used in a number of CSE101 assignments and tests.
// 
// USAGE:  (the executable is generated by a Makefile)
//     ./stackrecursion <INPUT FILE> <OUTPUT FILE>
// 
//     Only the first line of <INPUT FILE> is read, as a string. <OUTPUT FILE> contains all subsequences, each in a separate line.
// 
// 
// C. Seshadhri, Jan 2020, Oct 2020

#include <iostream>
#include "list.h"
#include <stack>
#include <stdexcept>
#include <fstream>
#include <array>
#include <vector> 
#include <algorithm>
#include <sstream>

using namespace std;


// This class keeps pairs of string. This is useful for simulating the recursion through as stack.
class Pair
{
    public:
        string in_str;
        string fixed_str;
};

// This function generates all subsequences of the input input_str, and outputs them as a list. This function does not use recursion.
// Input: string input_str
// Output: list of all subsequences of input_str

List allSubSeqStack(string input_str)
{
    List final_output; // generate empty list
    stack<class Pair> recurStack; // empty stack that performs the recursion
    Pair init, stacktop; // create a pair to push, to start the stac
    init.in_str = input_str; // put the initial string
    init.fixed_str = ""; // this is the fixed string, initially empty
    recurStack.push(init); // push this pair onto the top

    while(!recurStack.empty()) // while the stack is non-empty
    {
        stacktop = recurStack.top();// get the top pair in stack 
        recurStack.pop(); // remove the top element of stack
        if (stacktop.in_str.length() == 0) // input string is empty, so this is base case
        {
            final_output.insert(stacktop.fixed_str); // insert the fixed string onto list
            continue; // pop the next element of stack
        }
        char last = stacktop.in_str.back(); // get last element of in_str
        stacktop.in_str.pop_back(); // remove last element of stack
        Pair to_push; // setting up elements to push onto stack
        to_push.in_str = stacktop.in_str;
        to_push.fixed_str = stacktop.fixed_str; 
        recurStack.push(to_push); // this is for one recursive call
        to_push.fixed_str = last + stacktop.fixed_str; // this is for next recursive call
        recurStack.push(to_push);
    }
    return final_output;
}

// List allSubSeqStack(string input_str)
// {
//     List final_output;
//     stack<class Pair> recurStack;
//     Pair init, stacktop;
//     init.in_str=input_str;
//     init.fixed_str="";
//     recurStack.push(init);

//     while(!recurStack.empty()){
//         stacktop=recurStack.top();
//         recurStack.pop();
//         if(stacktop.in_str.length()==0)
//         {
//             final_output.insert(stacktop.fixed_str);
//             continue;
//         }
        
//         char last = stacktop.in_str.back();
//         stacktop.in_str.pop_back();
//         Pair to_push;
//         to_push.in_str = stacktop.in_str;
//         to_push.fixed_str = stacktop.fixed_str;
//         recurStack.push(to_push);
//         to_push.fixed_str = last + stacktop.fixed_str;
//         recurStack.push(to_push);


//     }

    
//     return final_output;
// }
//22min

// List allAnagrams(string input_str)
// {
//     List final_output; // generate empty list
//     stack<class Pair> recurStack; // empty stack that performs the recursion
//     Pair init, stacktop; // create a pair to push, to start the stac
//     init.in_str = input_str; // put the initial string
//     init.fixed_str = ""; // this is the fixed string, initially empty
//     recurStack.push(init); // push this pair onto the top

//     while(!recurStack.empty()) // while the stack is non-empty
//     {
//         stacktop = recurStack.top();// get the top pair in stack 
//         recurStack.pop(); // remove the top element of stack
//         if (stacktop.in_str.length() == 0) // input string is empty, so this is base case
//         {
//             final_output.insert(stacktop.fixed_str); // insert the fixed string onto list
//             continue; // pop the next element of stack
//         }
//         for(unsigned i = 0; i<stacktop.in_str.length();i++){
//             char last = stacktop.in_str.back(); // get last element of in_str
//             stacktop.in_str.pop_back(); // remove last element of stack
//             Pair to_push; // setting up elements to push onto stack
//             to_push.in_str = stacktop.in_str;
//             to_push.fixed_str = last+stacktop.fixed_str; 
//             recurStack.push(to_push); // this is for one recursive call
//             stacktop.in_str = last+stacktop.in_str;
//         }
        
//     }
//     return final_output;
// }


List allAnagrams(string input_str)
{
    List final_output;
    stack<class Pair> recurStack;
    Pair init, stacktop;
    init.in_str = input_str;
    init.fixed_str = "";
    recurStack.push(init);


    while(!recurStack.empty()){
        stacktop = recurStack.top();
        recurStack.pop();
        if(stacktop.in_str.length()==0){
            final_output.insert(stacktop.fixed_str);
            continue;
        }
        for(int i=0; i<stacktop.in_str.length(); i++){
            char last = stacktop.in_str.back();
            stacktop.in_str.pop_back();
            Pair to_push;
            to_push.in_str = stacktop.in_str;
            to_push.fixed_str = last + stacktop.fixed_str;
            recurStack.push(to_push);
            stacktop.in_str = last + stacktop.in_str;
        }

    }
    return final_output;
}
// 8 min

// List language(string input_str, unsigned k)
// {
//     List final_output; // generate empty list
//     stack<string> fixed_str_stack; // empty stack that performs the recursion

//     string fixed_stacktop;
//     unsigned K;

 
//     //final_output.insert("");
    
//     final_output.insert("");
//     for(K=k; K>0; K--){
//         fixed_str_stack.push("");
//         while(!fixed_str_stack.empty()) // while the stack is non-empty
//         {
//             fixed_stacktop = fixed_str_stack.top();
//             fixed_str_stack.pop();
//             if(fixed_stacktop.length()==K){
//                 final_output.insert(fixed_stacktop);
//                 continue;
//             }
//             for(unsigned i = 0; i<input_str.length(); i++){
//                 char to_fix = input_str[i];
//                 string to_push = to_fix+fixed_stacktop;
//                 fixed_str_stack.push(to_push);
//             }
            
//         }
//     }
    
//     return final_output;
// }

List language(string input_str, unsigned k)
{
    List final_output;
    stack<class Pair> recurStack;
    Pair init, stacktop;
    
    int i;
    int K = k;
    for(K = k; K>0; K--){
        init.in_str = input_str;
        init.fixed_str = "";
        recurStack.push(init);
        while(!recurStack.empty()){
            stacktop = recurStack.top();
            recurStack.pop();
            if(stacktop.fixed_str.length()==K){
                final_output.insert(stacktop.fixed_str);
                continue;
            }
            for(i = 0; i<input_str.length(); i++){
                char last = stacktop.in_str.back();
                Pair to_push;
                to_push.in_str = stacktop.in_str;
                to_push.fixed_str = last+stacktop.fixed_str;
                recurStack.push(to_push);
                stacktop.in_str.pop_back();
                stacktop.in_str = last + stacktop.in_str;
            
            }

        }
    }
    final_output.insert("");
    
    return final_output;
}
//14 min

void languageRec(string in_str, string fixed_str, unsigned k,List *list_ptr)
{
    if (fixed_str.length() == k) // base case
    {
        list_ptr->insert(fixed_str); // insert the fixed string into list
        return;
    }


    for(unsigned i = 0; i<in_str.length();i++){
        char last = in_str.back(); // get the last element of the string
        languageRec(in_str, last+fixed_str, k, list_ptr);
        in_str.pop_back(); // delete last element of in_str
        in_str=last+in_str;
    }

    
    
     // recursive call for subsequences without top
    return;
}

List languageRec(string in_str, unsigned k)
{
    List *final_output = new List(); // generate empty list
    for(int K = k; K>=0; K--){
        languageRec(in_str,"",K,final_output); // populate list with output
    }
    
    return *final_output;
}

// List stretch(string input_str, int k)
// {
//     List final_output; // generate empty list
//     stack<class Pair> recurStack; // empty stack that performs the recursion
//     Pair init, stacktop; // create a pair to push, to start the stac
//     init.in_str = input_str; // put the initial string
//     init.fixed_str = ""; // this is the fixed string, initially empty
//     recurStack.push(init); // push this pair onto the top

//     while(!recurStack.empty()) // while the stack is non-empty
//     {
//         stacktop = recurStack.top();// get the top pair in stack 
//         recurStack.pop(); // remove the top element of stack
//         if (stacktop.in_str.length() == 0) // input string is empty, so this is base case
//         {
//             final_output.insert(stacktop.fixed_str); // insert the fixed string onto list
//             continue; // pop the next element of stack
//         }
//         char last = stacktop.in_str.back(); // get last element of in_str
//         stacktop.in_str.pop_back(); // remove last element of stack
//         Pair to_push; // setting up elements to push onto stack
//         to_push.in_str = stacktop.in_str;
//         to_push.fixed_str = last + stacktop.fixed_str;
//         for(int K=k; K>0; K--){
//              // this is for next recursive call
//             recurStack.push(to_push);
//             to_push.fixed_str = last + to_push.fixed_str;
//         }
        
//     }
//     return final_output;
// }

List stretch(string input_str, int k)
{
    List final_output;
    stack<class Pair> recurStack;
    Pair init, stacktop;
    init.in_str = input_str;
    init.fixed_str = "";
    recurStack.push(init);
    while(!recurStack.empty()){
        stacktop = recurStack.top();
        recurStack.pop();
        if(stacktop.in_str.length()==0){
            final_output.insert(stacktop.fixed_str);
            continue;
        }
        char last = stacktop.in_str.back();
        stacktop.in_str.pop_back();
        Pair to_push;
        to_push.in_str = stacktop.in_str;
        to_push.fixed_str = stacktop.fixed_str;
        for(int K=k; K>0; K--){
            to_push.fixed_str=last+to_push.fixed_str;
            recurStack.push(to_push);
            
        }

    }
    return final_output;


    
}
//24 min

// List bubbling(string input_str)
// {
//     List final_output; // generate empty list
//     stack<class Pair> recurStack; // empty stack that performs the recursion
//     Pair init, stacktop; // create a pair to push, to start the stac
//     init.in_str = input_str; // put the initial string
//     init.fixed_str = ""; // this is the fixed string, initially empty
//     recurStack.push(init); // push this pair onto the top

//     while(!recurStack.empty()) // while the stack is non-empty
//     {
//         stacktop = recurStack.top();// get the top pair in stack 
//         recurStack.pop(); // remove the top element of stack
//         if (stacktop.in_str.length() == 1) // input string is empty, so this is base case
//         {
//             char in = stacktop.in_str[0];
//             final_output.insert(stacktop.fixed_str + in); // insert the fixed string onto list
//             //continue; // pop the next element of stack
//         }else{
//             char top = stacktop.in_str[0]; // get last element of in_str
//             char next = stacktop.in_str[1];
//             string i_str = stacktop.in_str;
//             i_str.erase(0,2);

//             stacktop.in_str.pop_back(); // remove last element of stack
//             Pair to_push1, to_push2; // setting up elements to push onto stack
//             to_push1.in_str = top + i_str;
//             to_push1.fixed_str = stacktop.fixed_str + next; 
//             to_push2.in_str = next + i_str;
//             to_push2.fixed_str = stacktop.fixed_str + top; 
//             recurStack.push(to_push1); // this is for one recursive call
//             recurStack.push(to_push2);
//         }
        
//     }
//     return final_output;
// }

List bubbling(string input_str)
{
    List final_output;
    stack<class Pair> recurStack;
    Pair init, stacktop;
    init.in_str = input_str;
    init.fixed_str = "";
    recurStack.push(init);

    while(!recurStack.empty()){
        cout<<"hello"<<endl;
        stacktop = recurStack.top();
        recurStack.pop();
        if(stacktop.in_str.length()==1){
            string to_insert = stacktop.fixed_str+stacktop.in_str[0];
            final_output.insert(to_insert);
            continue;
        }
        char first = stacktop.in_str[0];
        char next = stacktop.in_str[1];
        string in_str_to_append = stacktop.in_str;
        in_str_to_append.erase(0,2);
        Pair to_push1, to_push2;
        to_push1.in_str = next + in_str_to_append;
        to_push1.fixed_str = stacktop.fixed_str + first;
        to_push2.in_str = first + in_str_to_append;
        to_push2.fixed_str = stacktop.fixed_str + next;
        recurStack.push(to_push1);
        recurStack.push(to_push2);
    }

    return final_output;

}



// This recursive function generates all subsequences of the input in_str *appended* to the fixed_str, and outputs them in the list provided as an argument
// Input: string fixed_str, string in_str, pointer to list list_ptr
// Output: void, but list referenced by list_ptr is modified
// 
void allSubSeqRec(string in_str, string fixed_str, List *list_ptr)
{
    if (in_str.length() == 0) // base case
    {
        list_ptr->insert(fixed_str); // insert the fixed string into list
        return;
    }
    char top = in_str.back(); // get the last element of the string
    in_str.pop_back(); // delete last element of in_str
    allSubSeqRec(in_str, fixed_str, list_ptr); // recursive call for subsequences without top
    allSubSeqRec(in_str, top+fixed_str, list_ptr); //  recursive call for subsequences with top
    return;
}

// This function generates all subsequences of the input in_str, and outputs them as a list. This is the recursive version
// Input: string in_str
// Output: list of all subsequences of in_str
// 
List allSubSeq(string in_str)
{
    List *final_output = new List(); // generate empty list
    allSubSeqRec(in_str,"",final_output); // populate list with output
    return *final_output;
}

void allAnagramsRec(string in_str, string fixed_str, List *list_ptr)
{
    if (in_str.length() == 0) // base case
    {
        list_ptr->insert(fixed_str); // insert the fixed string into list
        return;
    }
    for(unsigned i = 0; i<in_str.length();i++){
        char top = in_str.back(); // get the last element of the string
        in_str.pop_back(); // delete last element of in_str
        allAnagramsRec(in_str, top+fixed_str, list_ptr);
        in_str=top+in_str;
    }
     // recursive call for subsequences without top
    return;
}

List allAnagramsRec(string in_str)
{
    List *final_output = new List(); // generate empty list
    allAnagramsRec(in_str,"",final_output); // populate list with output
    return *final_output;
}



void stretchRec(string in_str, string fixed_str, int k,List *list_ptr)
{
    if (in_str.length()==0) // base case
    {
        list_ptr->insert(fixed_str); // insert the fixed string into list
        return;
    }

    //for(unsigned K=k; K>0; K--){}
    char top = in_str.back(); // get the last element of the string
    in_str.pop_back(); // delete last element of in_str
    //allSubSeqRec(in_str, fixed_str, list_ptr); // recursive call for subsequences without top
    for(unsigned K=k; K>0; K--){
        fixed_str=top+fixed_str;
        stretchRec(in_str, fixed_str, k, list_ptr);
    }

        
     // recursive call for subsequences without top
    return;
}

List stretchRec(string in_str, int k)
{
    List *final_output = new List(); // generate empty list
    stretchRec(in_str,"",k,final_output); // populate list with output
    return *final_output;
}

void bubblingRec(string in_str, string fixed_str, List *list_ptr)
{
    if(in_str.length()==1){
        char in = in_str[0];
        list_ptr->insert(fixed_str+in);
        //list_ptr->insert((fixed_str+last)+in);
        return;
    }
    char top = in_str[0];
    char next = in_str[1];
    string input_str = in_str;
    input_str.erase(0,2);
    bubblingRec(next+input_str, fixed_str+top, list_ptr);
    bubblingRec(top+input_str, fixed_str+next, list_ptr);
    return;
}

List bubblingRec(string in_str)
{
    List *final_output = new List();
    bubblingRec(in_str, "", final_output);
    return *final_output;
}


int main(int argc, char** argv)
{
    if (argc < 3) // must provide two arguments as input
    {
        throw std::invalid_argument("Usage: ./hello <INPUT FILE> <OUTPUT FILE>"); // throw error
    }

    ifstream input; // stream for input file
    ofstream output; // stream for output file

    input.open(argv[1]); // open input file
    output.open(argv[2]); // open output file

    string in_str; // to store the input string from the file


    getline(input, in_str); // get the single string from the input file
    
    List myList = allAnagrams(in_str); // initializing the linked list
    myList.sort(); // sort the list
    
    output << myList.print("\n") << endl;  // print the list, using a new line as delimiter between items of the list
    
    myList.deleteList(); // free all the memory of this list

    input.close();
    output.close();
}
